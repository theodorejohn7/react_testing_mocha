'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = function (chai, utils, opt) {
    if (opt && opt.decompilerOptions) {
        _lodash2.default.assign(_reactDecompiler.options, opt.decompilerOptions);
    }

    registerMatcher(chai, utils, 'prop', _canBeAsserted2.default, function (name, expectedValue) {

        var validateValue = arguments.length > 1;
        var candidates = _lodash2.default.filter(getActual(this), function (elem) {
            return hasProp(elem, name);
        });

        var expectedValueMessage = function expectedValueMessage() {
            return validateValue ? ' and value ' + expectedValue : '';
        };

        this.assert(candidates.length && (!validateValue || _lodash2.default.some(candidates, function (elem) {
            return prop(elem, name) === expectedValue;
        })), 'expected ' + prettyPrint(this._obj) + ' to contain a prop with name \'' + name + '\'' + expectedValueMessage(), 'expected ' + prettyPrint(this._obj) + ' not to contain a prop with name \'' + name + '\'' + expectedValueMessage());

        return new chai.Assertion(candidates);
    });

    registerMatcher(chai, utils, 'text', _canBeAsserted2.default, function (text) {
        var actual = getActual(this);
        var candidates = _lodash2.default.filter(actual, function (elem) {
            return elem && elem.props && (elem.props.children === text || utils.type(elem.props.children) == 'array' && ~elem.props.children.indexOf(text));
        });
        this.assert(candidates.length, 'expected ' + prettyPrint(this._obj) + ' to have text \'' + text + '\'', 'expected ' + prettyPrint(this._obj) + ' not to have text \'' + text + '\'');
    });

    registerMatcher(chai, utils, 'elementOfType', _canBeAsserted2.default, function (type) {

        var actual = getActual(this);
        var candidates = _lodash2.default.filter(actual, function (elem) {
            return elem && elem.type === type;
        });
        this.assert(candidates.length, 'expected ' + prettyPrint(this._obj) + ' to have an element of type \'' + type + '\'', 'expected ' + prettyPrint(this._obj) + ' not to have an element of type \'' + type + '\'');

        return new chai.Assertion(candidates);
    });

    function getActual(assertion) {
        var assertee = assertion._obj;
        if (utils.flag(assertion, 'contains')) {
            return flatten(assertee);
        } else {
            return [].concat(assertee);
        }
    }
};

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _reactDecompiler = require('react-decompiler');

var _canBeAsserted = require('./can-be-asserted');

var _canBeAsserted2 = _interopRequireDefault(_canBeAsserted);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getAssertee(obj) {
    if (obj._reactInternalComponent && obj._reactInternalComponent._currentElement) {
        return obj._reactInternalComponent._currentElement;
    } else {
        return obj;
    }
}

function registerMatcher(chai, utils, name, predicate, matcher) {
    chai.Assertion.overwriteMethod(name, function (_super) {
        return function () {
            if (predicate(this._obj)) {
                utils.flag(this, 'object', getAssertee(this._obj));
                return matcher.apply(this, arguments);
            } else {
                return _super.apply(this, arguments);
            }
        };
    });
}

function flatten(vdom) {
    var res = [];
    _lodash2.default.forEach([].concat(vdom), function () {
        return visitVDom(vdom, res.push.bind(res));
    });
    return res;
}

function visitVDom(vdom, visitor) {
    if (vdom === undefined) {
        return;
    }
    if (Array.isArray(vdom)) {
        vdom.forEach(function (vdom) {
            visitVDom(vdom, visitor);
        });
    } else {
        visitor(vdom);
        if (vdom && vdom.props) {
            visitVDom(vdom.props.children, visitor);
        }
    }
}

function hasProp(elem, name) {
    if (!elem) return false;

    if (elem.props) {
        return elem.props.hasOwnProperty(name);
    } else if (elem._store && elem._store.props) {
        return elem._store.props.hasOwnProperty(name);
    }
    return false;
}

function prop(elem, name) {
    if (!elem) return;

    if (elem.props) {
        return elem.props[name];
    } else if (elem._store && elem._store.props) {
        return elem._store.props[name];
    } else {
        return;
    }
}

function prettyPrint(vdom) {
    return [].concat(vdom).map(_reactDecompiler.decompile).join(', ');
}
//# sourceMappingURL=chai-react-element.js.map
